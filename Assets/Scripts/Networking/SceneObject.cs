using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Text;
using RLD;
using System;
using DarkRift;
using Miniscript;

public class SceneObject : MonoBehaviour, IRTTransformGizmoListener, IDeletable, IDraggable
{
    // The Bundle that contains the Model attached to this object (null if none)
    // Generated by firebase
    public string BundleID { get; private set; }
    // The index of the model attached to this object, within the Bundle (-1 if none)
    public ushort BundleIndex { get; private set; }
    // The info for the current model. NOTE: this will be null until the bundle is loaded
    public BundleItem BundleItem { get; private set; }
    // references to the scripts
    public bool IsTransformNetworked { get; private set; }
    /// <summary>
    /// If we're currently loading a model
    /// </summary>
    public bool IsLoadingModel { get; private set; }
    /// <summary>
    /// If we're currently build-moving the object
    /// </summary>
    public bool IsBuildEditing { get; private set; }
    /// <summary>
    /// The model that's on this object
    /// </summary>
    public GameObject Model { get; private set; }
    /// <summary>
    /// The colliders on the attached model
    /// NB: Other scripts like PhysicsFollowHand may ignore this and
    /// directly get the colliders
    /// </summary>
    public List<Collider> ModelColliders { get; private set; }
    /// <summary>
    /// A Miniscript representation of this object
    /// </summary>
    public ValSceneObject MiniscriptValue { get; private set; }
    /// <summary>
    /// When grabbed with physics, we create a separate representation
    /// so that we can use transform.position on the mesh renderer, but
    /// rigidbody.MovePosition() on a physics-identical copy
    /// </summary>
    public PhysicsFollowHand PhysicsFollower { get; private set; }
    /// <summary>
    /// The rigidbody for this object. This will be null
    /// if no script requires a rigidbody
    /// </summary>
    public Rigidbody Rigidbody { get; private set; }

    /// <summary>
    /// The UserID that this object is currently being possessed by
    /// </summary>
    public ushort PossessedBy { get; private set; }

    public bool IsEnabled { get; private set; }

    // By default, everything is in the Terrain layer
    public int Layer { get {
            if (IsBuildEditing)
                return GLLayers.IgnoreSelectLayerNum;

            // Check to see the priority that the layer is being set with.
            // If it's low and we're being grabbed, then we use the grabbable layer.
            // If it's the max priority then use that requested layer
            if(CurrentGrabState == GrabState.GrabbedByOther
                || CurrentGrabState == GrabState.GrabbedBySelf
                || CurrentGrabState == GrabState.PendingGrabbedBySelf)
            {
                int reqLayer = _behaviorLayerRequests.Get(out int priority);
                if (priority == _behaviorLayerRequests.GetMaxPriority())
                    return reqLayer;
                return GLLayers.GrabbedLayerNum;
            }
            return _behaviorLayerRequests.Get(out int junk);
            } }
    // By default, children are default tag
    // Behaviors may request that the tag be changed (e.g. Grabbable)
    // this only affects children elements, SceneObject's tag is never changed
    public string Tag { get { return _behaviorTagRequests.Get(out int junk); }}
    /// <summary>
    /// The materials attached to this object
    /// They will be null until the MaterialInfos load from the bundle
    /// Individual elements will be null until a DRMaterial is present for them
    /// </summary>
    public SceneMaterial[] SceneMaterials { get; private set; }

    public enum GrabState
    {
        Ungrabbed,
        PendingGrabbedBySelf,
        GrabbedBySelf,
        GrabbedByOther,
        PendingUngrabbed
    }
    //public GrabState CurrentGrabState { get; private set; }
    public GrabState CurrentGrabState;
    public bool AreWeGrabbing { get { return CurrentGrabState == GrabState.GrabbedBySelf || CurrentGrabState == GrabState.PendingGrabbedBySelf; } }
    public bool IsSomeoneGrabbing { get { return CurrentGrabState != GrabState.Ungrabbed && CurrentGrabState != GrabState.PendingUngrabbed; } }
    public ushort GrabbingUser { get { return _drObject == null ? DRObject.NoneGrabbing : _drObject.GrabbedBy; } }
    public bool DoWeOwn { get { return _drObject != null && _drObject.OwnerID == DarkRiftConnection.Instance.OurID; } }
    [SerializeField]
    public string Name;
    public bool DidWeCreate { get; private set; }
    public bool HasInit { get; private set; }

    /// <summary>
    /// Called whenever behaviors are added/removed
    /// </summary>
    public Action OnBehaviorsUpdated;
    /// <summary>
    /// Called whenever either ModelColliders or AABBColliders change
    /// </summary>
    public Action OnCollidersChange;
    /// <summary>
    /// Called when the server changes the name.
    /// Bool is for if we were the ones who changed it
    /// </summary>
    public Action<bool> OnServerChangeObjectName;
    /// <summary>
    /// Called whenever the owner of the object changes
    /// Prev owner, new owner
    /// </summary>
    public Action<ushort, ushort> OnOwnershipChange;

    /// <summary>
    /// Keep some behaviors cached, as they're frequently needed
    /// </summary>
    public CharacterBehavior CharacterBehavior;
    public RagdollBehavior RagdollBehavior;
    public MovingPlatformBehavior MovingPlatformBehavior;
    private readonly List<BaseBehavior> _attachedBehaviors = new List<BaseBehavior>();
    // Working array to avoid an alloc
    private readonly List<ExposedVariable> _exposedVariables = new List<ExposedVariable>();
    private readonly List<ExposedFunction> _exposedFunctions = new List<ExposedFunction>();
    private readonly List<ExposedEvent> _exposedEvents = new List<ExposedEvent>();
    private readonly List<ExposedVariable> _alwaysExposedVariables = new List<ExposedVariable>();
    private static readonly List<ExposedFunction> _alwaysExposedFunctions = new List<ExposedFunction>();
    private readonly List<ExposedEvent> _alwaysExposedEvents = new List<ExposedEvent>();
    private static readonly ValString OnOwnerChangeStrVal = ValString.Create("OnOwnerChange", false);
    private static readonly ValString FixedTimeStrVal = ValString.Create("fixedDeltaTime", false);
    private static readonly ValString PointStrVal = ValString.Create("point", false);
    private static readonly ValString AxisStrVal = ValString.Create("axis", false);
    private static readonly ValString AngleStrVal = ValString.Create("angle", false);
    private static readonly ValString ScriptNameVal = ValString.Create("scriptName", false);
    private static readonly ValString EnabledVal = ValString.Create("enabled", false);
    private static readonly ValString ScaleVal = ValString.Create("scale", false);
    private static readonly ValString NetworkChangeVal = ValString.Create("networkChange", false);

    /// <summary>
    /// The script that handles sending out pos/rot/vel
    /// messages
    /// </summary>
    public NetworkObject NetObj { get; private set; }

    private static bool _hasLoadedIntrinsics = false;

    /// <summary>
    /// The object whos data is shared on the server
    /// </summary>
    private DRObject _drObject;

    /// <summary>
    /// Script to draw an outline around the model
    /// </summary>
    private ObjectOutline _objectOutline;

    /// <summary>
    /// The receipt from BundleManager for loading the
    /// object. We use this to early cancel the load
    /// </summary>
    private uint _loadObjReceipt = uint.MaxValue;

    /// <summary>
    /// Keep track of which behaviors we previously had before we deleted
    /// the object. This way we know how to restore the behaviors
    /// </summary>
    private readonly List<SerializedBehavior> _behaviorsAddedBeforeDelete = new List<SerializedBehavior>();

    /// <summary>
    /// The display we have for a model that's
    /// still loading
    /// </summary>
    private GameObject _placeholderBox;
    /// <summary>
    /// The auto-created collider for this object
    /// </summary>
    public AABBCollider AABBCollider { get; private set; }
    /// <summary>
    /// The auto-created collider for build mode. Used
    /// to enable grabbing objects without their own
    /// collider. This is turned off if we build select something
    /// </summary>
    public BuildGrabbable BuildGrabbable { get; private set; }
    /// <summary>
    /// The behaviors requesting tags
    /// </summary>
    private RequestQueue<string> _behaviorTagRequests;
    /// <summary>
    /// The behaviors requesting layers
    /// </summary>
    private RequestQueue<int> _behaviorLayerRequests;
    /// <summary>
    /// The behaviors requesting kinematic
    /// </summary>
    private RequestQueue<bool> _behaviorKinematicRequests;

    // Used so that we can find all behaviors to remove
    private static readonly List<Component> _workingComponentList = new List<Component>();

#pragma warning disable CS0649
    // Just for debugging
    private TMPro.TextMeshPro _debugText;
#pragma warning restore CS0649

    public void Init(DRObject dRObject, bool didWeCreate, bool isModelAlreadyLoaded)
    {
        if (HasInit)
            Debug.LogError("Double init!", this);
        HasInit = true;
        PossessedBy = ushort.MaxValue;
        MiniscriptValue = new ValSceneObject(this);
        _behaviorLayerRequests = new RequestQueue<int>(GLLayers.TerrainLayerNum);
        _behaviorTagRequests = new RequestQueue<string>(GLLayers.DefaultTag);
        _behaviorKinematicRequests = new RequestQueue<bool>(false);
        // SceneObjects always have a SceneObject tag
        gameObject.tag = GLLayers.SceneObjectTag;

        _drObject = dRObject;
        BundleID = _drObject.BundleID;
        BundleIndex = _drObject.ModelIndex;
        Name = _drObject.Name;
        gameObject.name = dRObject.GetID().ToString();
        name = dRObject.GetID().ToString();
        IsEnabled = dRObject.IsEnabled;
        CurrentGrabState = GrabberID2GrabState(_drObject.GrabbedBy);
        DidWeCreate = didWeCreate;
        RefreshLayer();
        RefreshTag();
        //Debug.Log("Init with owner " + GetOwnerID() + " our ID " + DarkRiftConnection.Instance.OurID);
        //Debug.Log("Init scene object " + dRObject.GetID() + " bundle " + BundleID + " model " + ModelIndex);
        //Debug.Log("Init with pos: " + transform.localPosition + " parent: " + transform.parent.name);

        // Now spawn the actual display of the model
        if (!isModelAlreadyLoaded)
        {
            if (BundleIndex != ushort.MaxValue && !string.IsNullOrEmpty(BundleID))
            {
                IsLoadingModel = true;
                _loadObjReceipt = BundleManager.Instance.LoadGameObjectFromBundle(BundleID, BundleIndex, transform, 0, OnModelLoaded, OnBundleItemLoaded);
            }
        }
        else if(BundleIndex != ushort.MaxValue && !string.IsNullOrEmpty(BundleID))
        {
            // Find the model in the hierarchy
            // It's the only child that's not a BuildGrabbable/AABBCollider
            //TODO PhysicsFollow?
            int numChildren = transform.childCount;
            for(int i = 0; i < numChildren; i++)
            {
                Transform candidate = transform.GetChild(i);
                if (candidate.gameObject.name == BuildGrabbableManager.BuildGrabbableName
                    || candidate.gameObject.name == AABBColliderManager.AABBColliderName)
                    continue;
                Model = candidate.gameObject;
                break;
            }
            if(Model == null)
            {
                Debug.LogError("Failed to find model! Will reload");
                IsLoadingModel = true;
                _loadObjReceipt = BundleManager.Instance.LoadGameObjectFromBundle(BundleID, BundleIndex, transform, 0, OnModelLoaded, OnBundleItemLoaded);
            }
            else
            {
                // Load the model colliders
                if (ModelColliders == null)
                    ModelColliders = new List<Collider>();
                if (Model != null)
                    Model.GetComponentsInChildren(ModelColliders);
            }
        }

        // Each object will have some materials attached to it
        // we need to retrieve those materials from an assetbundle, if the material is from a bundle
        // and we need to get the material info from the network if someone else created this material
        // or we need to create a network representation of the material
        SceneMaterialManager.Instance.GetOrCreateSceneMaterialsFor(this, DidWeCreate);

        // Behaviors will be added in DeserializeFromDRObject if this is from the server

        // If this is a local restore, then we need to re-add the behaviors that were previously attached
        foreach(var behavior in _behaviorsAddedBeforeDelete)
        {
            BehaviorInfo behaviorData;
            if (behavior.IsUserScript)
                behaviorData = UserScriptManager.Instance.GetBehaviorInfoFromID(behavior.BehaviorID);
            else
                behaviorData = CSharpBehaviorManager.Instance.GetBehaviorInfoFromID(behavior.BehaviorID);

            if (behaviorData == null)
            {
                Debug.LogWarning("Behavior not found for " + behavior.BehaviorID);
                continue;
            }
            AddBehavior(behaviorData, false, false, behavior);
        }

        //_debugText = new GameObject("debugText", typeof(TMPro.TextMeshPro)).GetComponent<TMPro.TextMeshPro>();
        //_debugText.transform.SetParent(transform);
        //_debugText.transform.localPosition = new Vector3(0, 10, 0);
        //_debugText.text = _drObject.OwnerID.ToString();
        ConfigureForGrabState();
    }
    public void SetBundleItem(BundleItem bundleItem)
    {
        BundleItem = bundleItem;
    }
    public void Start()
    {
        // If we hit start without being init, then what most likely happened
        // is that we duplicated an existing object. So we init the new object
        // from the existing object here
        if (HasInit)
            return;

        // Remove any attached behaviors
        GetComponents(typeof(BaseBehavior), _workingComponentList);
        //Debug.Log("Removing " + _workingComponentList.Count + " components");
        for(int i = 0; i < _workingComponentList.Count; i++)
        {
            var component = _workingComponentList[i];
            //Debug.Log("Removing of type " + component.GetType().ToString());
            Destroy(component);
        }

        // Remove any BuildGrabbable and AABB Collider, this is because they rely on a pool, so it's just
        // easier to remove the existing one and start over
        Transform buildGrabbable = transform.Find(BuildGrabbableManager.BuildGrabbableName);
        if (buildGrabbable != null)
            Destroy(buildGrabbable.gameObject);
        Transform aabbCollider = transform.Find(AABBColliderManager.AABBColliderName);
        if (aabbCollider != null)
            Destroy(aabbCollider.gameObject);
        Transform placeholderBox = transform.Find(PlaceholderManager.PlaceholderGameObjectName);
        if (placeholderBox != null)
            Destroy(placeholderBox.gameObject);

        Rigidbody = GetComponent<Rigidbody>();
        NetObj = GetComponent<NetworkObject>();
        SceneObjectManager.Instance.SceneObjectNeedsInit(gameObject.name, this);
    }
    public void OnSceneMaterialsLoaded(SceneMaterial[] sceneMaterials)
    {
        //Debug.Log("Loaded SceneMaterials, count " + sceneMaterials.Length);
        if (SceneMaterials != null)
            Debug.LogError("Overwriting SceneMaterials for " + GetID(), this);

        SceneMaterials = sceneMaterials;
        //foreach (var mat in SceneMaterials)
            //Debug.Log(mat == null ? "null" : mat.MaterialInfo.Name);
    }
    public void OnSceneMaterialLoaded(SceneMaterial sceneMaterial, int materialIndexWithinRenderer)
    {
        Debug.Log("Loaded SceneMaterial #" + materialIndexWithinRenderer);
        if (materialIndexWithinRenderer >= SceneMaterials.Length)
        {
            Debug.LogError("Can't set mat #" + materialIndexWithinRenderer + " we have only " + SceneMaterials.Length + " slots");
            return;
        }
        if (SceneMaterials[materialIndexWithinRenderer] != null)
            Debug.LogError("Overwriting material #" + materialIndexWithinRenderer + " on object " + GetID(), this);
        SceneMaterials[materialIndexWithinRenderer] = sceneMaterial;
    }
    void OnBundleItemLoaded(int loadID, BundleItem bundleItem)
    {
        if(this == null)
            return;
        BundleItem = bundleItem;
        // If we've already finished loading the model, drop this
        // can't imagine this ever happening, but w/e
        if (!IsLoadingModel)
        {
            Debug.LogWarning("Dropping bundle item load, already have model");
            return;
        }
        if (_placeholderBox != null)
        {
            Debug.LogError("Double loading placeholder box");
            return;
        }
        int layer = Layer;
        // Don't use the none layer for the placeholder, otherwise it's
        // invisible
        if (layer == GLLayers.NoneLayerNum)
            layer = GLLayers.DefaultLayerNum;
        if(IsEnabled)
            _placeholderBox = PlaceholderManager.Instance.LoadPlaceholderBox(transform, bundleItem, layer);
    }
    void OnModelLoaded(int loadID, GameObject model)
    {
        IsLoadingModel = false;
        _loadObjReceipt = uint.MaxValue;
        Model = model;
        model.transform.localRotation = Quaternion.identity;
        if (ModelColliders == null)
            ModelColliders = new List<Collider>();
        if (Model != null)
            Model.GetComponentsInChildren(ModelColliders);
        RefreshLayer();
        RefreshTag();
        if (!IsEnabled)
            model.SetActive(false);
        // If we have a placeholder box, return
        if (_placeholderBox != null)
            PlaceholderManager.Instance.ReturnPlaceholderBox(_placeholderBox);
        _placeholderBox = null;
        // If we are highlighting, update the highlighted
        if (_objectOutline != null)
            _objectOutline.AddObjectModel(model);
        // Re-check if we need an AABB collider
        ReevaluateAABBCollider();
        if (OnCollidersChange != null)
            OnCollidersChange();

        // We need to reset the physics parameters
        // after the model loads, because otherwise
        // Unity incorrectly accounts for the BuildGrabbable
        // having an influence on the COM / Inertia tensor
        if(Rigidbody != null)
        {
            Rigidbody.ResetCenterOfMass();
            Rigidbody.ResetInertiaTensor();
        }
        ConfigureForGrabState();

        // Notify the behaviors
        for (int i = 0; i < _attachedBehaviors.Count; i++)
            _attachedBehaviors[i].OnModelLoaded();
    }
    public void OnPossess(ushort playerID)
    {
        if (PossessedBy != ushort.MaxValue)
            Debug.LogWarning("Overwriting possessed by, was " + PossessedBy + " now " + playerID);
        PossessedBy = playerID;
    }
    public void OnDepossess()
    {
        if (PossessedBy != ushort.MaxValue)
            Debug.LogWarning("Depossess when no user is currently in possession");
        PossessedBy = ushort.MaxValue;
    }
    public void OnBuildGrabbableSet(BuildGrabbable buildGrabbable)
    {
        BuildGrabbable = buildGrabbable;
        if(BuildGrabbable == null)
        {
            Debug.LogError("Null build grabbable!");
            return;
        }
        BuildGrabbable.gameObject.SetActive(!IsBuildEditing);
    }
    public void ClearBuildGrabbable()
    {
        BuildGrabbable = null;
    }
    public void SetObjectOutline(ObjectOutline.OutlineState outlineState)
    {
        if (_objectOutline == null)
        {
            _objectOutline = gameObject.AddComponent<ObjectOutline>();
            _objectOutline.Init(this);
            if (Model != null)
                _objectOutline.AddObjectModel(Model);
        }

        _objectOutline.SetHighlightState(outlineState);
    }
    public void AddNetworking()
    {
        //Debug.Log("Adding networking");
        if (IsTransformNetworked)
        {
            Debug.Log("Not adding networking, we already have it");
            return;
        }
        IsTransformNetworked = true;
        //Debug.Log("Creating transform syncing for " + _drObject.GetID(), this);
        // We might already have a NetworkObject if we spawned from an existing
        if(NetObj == null)
            NetObj = gameObject.AddComponent<NetworkObject>();
        NetObj.Init(this, _drObject);
    }
    private void RefreshLayer()
    {
        int layer = Layer;
        gameObject.layer = layer;
        //Debug.Log("Refresh layer using " + layer);
        // Handle if we're trying to disable
        // all collisions
        if(layer == GLLayers.NoneLayerNum)
        {
            if (ModelColliders != null)
            {
                //Debug.Log("Refreshing with layer none!");
                foreach(var collider in ModelColliders)
                    collider.enabled = false;
            }
            if (AABBCollider != null)
                AABBCollider.SetCollidersOn(false);
            return;
        }
        if (Model != null)
            Model.SetLayerRecursively(layer);
        if (ModelColliders != null)
        {
            foreach(var collider in ModelColliders)
                collider.enabled = true;
        }
        if (AABBCollider != null)
        {
            AABBCollider.SetCollidersOn(true);
            AABBCollider.gameObject.layer = layer;
        }
    }
    public void BehaviorRequestedLayer(int requestedLayer, BaseBehavior behavior, int priority)
    {
        //Debug.Log("Req set layer to " + requestedLayer + " by " + behavior.GetType().ToString());
        //if (_behaviorSettingLayer != behavior && _behaviorSettingLayer != null)
        //Debug.LogError("Potentially double setting layer, this is not yet supported. Was " + _behaviorSettingLayer.GetBehaviorInfo().Name + " now " + behavior.GetBehaviorInfo().Name);
        if (_behaviorLayerRequests.AddRequest(requestedLayer, behavior, priority))
            RefreshLayer();
    }
    public void BehaviorClearRequestLayer(BaseBehavior behavior, int priority)
    {
        if (_behaviorLayerRequests.ClearRequest(behavior, priority))
            RefreshLayer();
    }
    public void BehaviorRequestedKinematic(bool isKinematic, BaseBehavior behavior, int priority)
    {
        if (_behaviorKinematicRequests.AddRequest(isKinematic, behavior, priority))
            RefreshKinematic();
    }
    public void BehaviorClearRequestKinematic(BaseBehavior behavior, int priority)
    {
        if (_behaviorKinematicRequests.ClearRequest(behavior, priority))
            RefreshKinematic();
    }
    private void RefreshTag()
    {
        string tag = Tag;
        if (Model != null)
            Model.SetTagRecursively(tag);
        if (AABBCollider != null)
            AABBCollider.gameObject.tag = tag;
    }
    private void RefreshKinematic()
    {
        if (Rigidbody == null)
            return;
        Rigidbody.isKinematic = _behaviorKinematicRequests.Get(out int _);
    }
    public void BehaviorRequestedTag(string requestedTag, BaseBehavior behavior, int priority)
    {
        if(_behaviorTagRequests.AddRequest(requestedTag, behavior, priority))
            RefreshTag();
    }
    public void BehaviorClearRequestTag(BaseBehavior behavior, int priority)
    {
        if (_behaviorTagRequests.ClearRequest(behavior, priority))
            RefreshTag();
    }
    public void RemoveNetworking()
    {
        Debug.Log("Removing networking for #" + GetID());
        if (!IsTransformNetworked)
        {
            Debug.LogError("Can't remove networking, not currently networked!");
            return;
        }
        if (NetObj != null)
            Destroy(NetObj);
        NetObj = null;
        IsTransformNetworked = false;
    }
    private bool DoesAnyAttachedBehaviorRequireNetworking()
    {
        foreach (var behave in _attachedBehaviors)
        {
            if (behave.DoesRequirePosRotScaleSyncing())
                return true;
        }
        return false;
    }
    private bool DoesAnyAttachedBehaviorRequireCollider()
    {
        foreach (var behave in _attachedBehaviors)
        {
            if (behave.DoesRequireCollider())
                return true;
        }
        return false;
    }
    private bool DoesAnyAttachedBehaviorRequireRigidbody()
    {
        foreach (var behave in _attachedBehaviors)
        {
            if (behave.DoesRequireRigidbody())
                return true;
        }
        return false;
    }
    /// <summary>
    /// Re-checks if we need a collider based on the AABB attached to this object
    /// Valid reasons are that a behavior wants it, but model is loading or the model
    /// doesn't contain a collider
    /// </summary>
    /// <returns>If the AABBCollider was added or removed</returns>
    private bool ReevaluateAABBCollider()
    {
        bool didChange = false;
        bool behaviorNeeds = DoesAnyAttachedBehaviorRequireCollider();
        if(!behaviorNeeds)
        {
            if(AABBCollider != null)
            {
                AABBColliderManager.Instance.ReturnAABBCollider(AABBCollider);
                //Debug.Log("Returning AABBCollider, we don't need it anymore");
                didChange = true;
            }
            AABBCollider = null;
            return didChange;
        }

        // If we have a model, and it contains a collider, there's no need to add one
        if(!IsLoadingModel && ModelColliders != null && ModelColliders.Count > 0)
        {
            //Debug.Log("Behavior needs collider, but we have one");
            if (AABBCollider != null)
            {
                AABBColliderManager.Instance.ReturnAABBCollider(AABBCollider);
                didChange = true;
            }
            AABBCollider = null;
            return didChange;
        }
        if(AABBCollider == null)
        {
            //Debug.Log("IsLoading model " + IsLoadingModel + " colliders : " + (ModelColliders == null ? "null" : ModelColliders.Count.ToString()));
            //Debug.Log("Adding AABBCollider to #" + GetObjectID(), this);
            AABBCollider = AABBColliderManager.Instance.RequestAABBCollider(this);
            // configure the layers on the AABB collider
            if (Layer == GLLayers.NoneLayerNum)
                AABBCollider.SetCollidersOn(false);
            else
                AABBCollider.gameObject.layer = Layer;
            didChange = true;
        }

        if (!IsEnabled && AABBCollider != null)
            AABBCollider.gameObject.SetActive(false);
        return didChange;
    }
    /// <summary>
    /// Creates a new behavior for this object.
    /// This can occur as a result of:
    ///     1) adding a behavior
    ///     2) duplicating an object
    ///     3) an update from the server
    /// </summary>
    /// <param name="behaviorData"></param>
    /// <param name="didWeAdd">Whether or not this new behavior came from an action we did</param>
    /// <param name="updateServer">Whether to notify the server. This is false if someone else added the object, or if we duplicated the object (b/c it'll be in the fully serialized object)</param>
    /// <param name="existingSerializedBehavior">Existing param data for the behavior. Null if we created.</param>
    /// <returns></returns>
    public BaseBehavior AddBehavior(BehaviorInfo behaviorData, bool didWeAdd, bool updateServer, SerializedBehavior existingSerializedBehavior)
    {
        Debug.Log("Adding behavior " + behaviorData.Name);
        BaseBehavior behavior = behaviorData.Create(this);

        //TODO prevent double adding behaviors

        if (existingSerializedBehavior != null)
            behavior.SetSerializedBehavior(existingSerializedBehavior, false);
        _attachedBehaviors.Add(behavior);
        if (!IsEnabled)
            behavior.enabled = false;
        // Keep certain behaviors cached for easy access
        if (!behaviorData.IsNetworkedScript())
        {
            if (behaviorData.BehaviorID == SharedBehaviorKeys.CharacterBehaviorID)
                CharacterBehavior = behavior as CharacterBehavior;
            else if (behaviorData.BehaviorID == SharedBehaviorKeys.RagdollBehaviorID)
                RagdollBehavior = behavior as RagdollBehavior;
            else if (behaviorData.BehaviorID == SharedBehaviorKeys.MovingPlatformBehaviorID)
                MovingPlatformBehavior = behavior as MovingPlatformBehavior;
        }

        if (!IsTransformNetworked && behavior.DoesRequirePosRotScaleSyncing())
            AddNetworking();
        if (Rigidbody == null && behavior.DoesRequireRigidbody())
            Rigidbody = gameObject.AddComponent<Rigidbody>();
        if (ReevaluateAABBCollider())
        {
            if (OnCollidersChange != null)
                OnCollidersChange();
        }

        // We init here, because the behavior expects to already have the collider/rigidbody/networking
        // made and ready by the time it hits init
        behavior.Init(behaviorData, this);

        if (didWeAdd && updateServer)
        {
            //Debug.Log("Updating behaviors as: " + sb.ToString());
            behavior.CreateSerializedBehavior(_drObject);
        }
        else
        {
            // Update the UI, if this object is selected
            if (PropertiesAndBehaviors.Instance != null && PropertiesAndBehaviors.Instance.SelectedObject == this)
                PropertiesAndBehaviors.Instance.AddComponentCard(behavior);
        }

        if (OnBehaviorsUpdated != null)
            OnBehaviorsUpdated();
        return behavior;
    }
    public void RemoveBehavior(BaseBehavior behaviorInstance, bool didWeRemove)
    {
        Debug.Log("Destroying behavior " + behaviorInstance.GetBehaviorInfo().Name);
        // Handle if this behavior had previously configured the tag
        if (_behaviorLayerRequests.RemoveRequester(behaviorInstance))
            RefreshLayer();
        if (_behaviorTagRequests.RemoveRequester(behaviorInstance))
            RefreshTag();
        // TODO prob make more sense to use inheritance to guarantee monobehavior
        _attachedBehaviors.Remove(behaviorInstance);
        if (behaviorInstance == CharacterBehavior)
            CharacterBehavior = null;
        else if (behaviorInstance == RagdollBehavior)
            RagdollBehavior = null;
        else if (behaviorInstance == MovingPlatformBehavior)
            MovingPlatformBehavior = null;
        behaviorInstance.Destroy();

        if (IsTransformNetworked && !DoesAnyAttachedBehaviorRequireNetworking())
        {
            Debug.Log("Stopping networking for " + _drObject.GetID());
            RemoveNetworking();
        }
        // If we have a Rigidbody, the behavior we're removing has no rigidbody, and no other behaviors need a rigidbody
        // then we can just remove the Rigidbody
        if(Rigidbody != null && behaviorInstance.DoesRequireRigidbody() && !DoesAnyAttachedBehaviorRequireRigidbody())
        {
            Destroy(Rigidbody);
            Rigidbody = null;
        }
        if (ReevaluateAABBCollider())
        {
            if (OnCollidersChange != null)
                OnCollidersChange();
        }

        if (didWeRemove)
        {
            Debug.Log("Removing " + _drObject.GetID());
            BehaviorInfo info = behaviorInstance.GetBehaviorInfo();
            DarkRiftConnection.Instance.RemoveBehaviorFromObject(_drObject, info.IsNetworkedScript(), info.BehaviorID);
        }
        else
        {
            Debug.Log("updating DRobject from behavior remove");
            // Update our local copy
            BehaviorInfo info = behaviorInstance.GetBehaviorInfo();
            _drObject.RemoveBehavior(info.IsNetworkedScript(), info.BehaviorID);
            // Update the UI, if this object is selected
            if (PropertiesAndBehaviors.Instance != null && PropertiesAndBehaviors.Instance.SelectedObject == this)
            {
                Debug.Log("removing component card");
                PropertiesAndBehaviors.Instance.RemoveComponentCard(behaviorInstance);
            }
        }
        // Actually remove that behavior from our GameObject
        Destroy(behaviorInstance);
        if (OnBehaviorsUpdated != null)
            OnBehaviorsUpdated();
    }
    /// <summary>
    /// Called by Behaviors that changed their RequiresRigidbody
    /// status. This way we stay up to date with whether we have
    /// a rigidbody or not
    /// </summary>
    public void RefreshRigidbody()
    {
        bool needsRigid = DoesAnyAttachedBehaviorRequireRigidbody();
        //Debug.Log("Needs rigid " + needsRigid + " has " + (Rigidbody == null ? "null" : "inst"));
        if (needsRigid && Rigidbody == null)
            Rigidbody = gameObject.AddComponent<Rigidbody>();
        else if(!needsRigid && Rigidbody != null)
        {
            Destroy(Rigidbody);
            Rigidbody = null;
        }
    }
    public List<BaseBehavior> GetBehaviors()
    {
        return _attachedBehaviors;
    }
    public BaseGrabbable GetGrabbable(bool isGrabbingUserInPlayMode)
    {
        if (!isGrabbingUserInPlayMode)
        {
            if (BuildGrabbable == null)
                Debug.LogError("No build grabbable?");
            return BuildGrabbable;
        }
        for(int i = 0; i < _attachedBehaviors.Count; i++)
        {
            //var behavior = _attachedBehaviors[i];
            GrabbableBehavior grabBehav = _attachedBehaviors[i] as GrabbableBehavior;
            if (grabBehav != null)
                return grabBehav.AddedPlayGrabbable;
        }
        return null;
    }
    public void UpdateName(string newName, bool didWeChange, bool isChangeFromServer)
    {
        Debug.Log("Updating name from " + Name + " to " + newName);

        if (isChangeFromServer)
        {
            Debug.Log("updating DRobject name from server " + newName);
            // Update our local copy (unless we changed it, in which case we
            // do nothing, because we may have sent out a newer version since now)
            if (!didWeChange)
            {
                _drObject.SetName(newName);
                Name = newName;
            }

            if (OnServerChangeObjectName != null)
                OnServerChangeObjectName(didWeChange);
        }
        else
        {
            Name = newName;
            DarkRiftConnection.Instance.UpdateObjectName(_drObject, newName);
        }
    }
    /// <summary>
    /// Called when RLD or user code deletes this object
    /// </summary>
    public void OnDeleted()
    {
        Debug.Log("Deleted " + _drObject.GetID());
        HasInit = false;
        // Remove all added behaviors, and store them in case we restore this object
        foreach(var behavior in _attachedBehaviors)
            _behaviorsAddedBeforeDelete.Add(behavior.GetSerializedObject());

        for(int i = _attachedBehaviors.Count - 1; i >= 0; i--)
            RemoveBehavior(_attachedBehaviors[i], false);// We DID remove, but there's no need to update server
        
        SceneObjectManager.Instance.SceneObjectDeleted(this);
    }
    /// <summary>
    /// Called when the user ctrl-Z the deletion
    /// </summary>
    public void OnRestored()
    {
        Debug.Log("Restored " + _drObject.GetID());
        SceneObjectManager.Instance.SceneObjectRestored(this);
    }
    void OnDestroy()
    {
        if (!Orchestrator.Instance.IsAppClosing)
        {
            //Debug.Log("Destroying sceneobject \"" + Name + "\"");
            for(int i = 0; i < _attachedBehaviors.Count; i++)
            {
                //Debug.Log("Destroying behavior " + behavior.GetBehaviorInfo().Name);
                _attachedBehaviors[i].Destroy();
            }
            if (IsLoadingModel)
            {
                Debug.Log("Cancelling obj load as we're destroying this obj");
                if (_loadObjReceipt == uint.MaxValue)
                    Debug.LogError("Can't cancel load, no load receipt!");
                else
                    BundleManager.Instance.CancelLoad(_loadObjReceipt);
                _loadObjReceipt = uint.MaxValue;
            }
            if(BuildGrabbable != null)
            {
                Debug.LogError("Destroying with a build grabbable on " + Name + " obj " + gameObject.name);
            }
            //Debug.Log("Scene object " + Name + " #" + GetObjectID() + " destroyed");
        }
    }

    /// <summary>
    /// Updates the object ID.
    /// Called when server responds to our request to add an object
    /// </summary>
    /// <param name="objectID"></param>
    public void SetObjectID(ushort objectID)
    {
        _drObject.ObjectID = objectID;
        //Debug.Log("New object ID " + objectID, this);
        gameObject.name = objectID.ToString();
    }
    public ushort GetID()
    {
        return _drObject.GetID();
    }
    public void SetOwner(ushort newOwner, uint newTime)
    {
        ushort prevOwner = _drObject.OwnerID;
        _drObject.OwnerID = newOwner;
        _drObject.OwnershipTime = newTime;
        Debug.Log("New owner, was " + prevOwner + " now " + newOwner);
        if (OnOwnershipChange != null)
            OnOwnershipChange(prevOwner, newOwner);
        InvokeEventOnBehaviors(OnOwnerChangeStrVal);
        ConfigureForGrabState();
    }
    public uint GetOwnerID()
    {
        return _drObject.OwnerID;
    }
    public DRObject GetDRObject()
    {
        return _drObject;
    }
    private void SetChildrenColorTesting(Color col)
    {
        MeshRenderer[] childRenderers = gameObject.GetComponentsInChildren<MeshRenderer>();
        foreach (var child in childRenderers)
            child.material.SetColor(col);
    }
    private void ConfigureForGrabState()
    {
        // If we're being grabbed, kinematic should be on
        Rigidbody rigidbody = Rigidbody;
        if(rigidbody != null)
        {
            GrabbableBehavior grab;
            switch (CurrentGrabState)
            {
                case GrabState.Ungrabbed:
                case GrabState.PendingUngrabbed:
                    // Request kinematic be false
                    _behaviorKinematicRequests.AddRequest(false, null, 0);
                    RefreshKinematic();
                    if(PhysicsFollower != null)
                    {
                        PhysicsFollower.ResetState();
                        SimplePool.Instance.Despawn(PhysicsFollower.gameObject);
                        PhysicsFollower = null;
                    }
                    break;
                case GrabState.GrabbedBySelf:
                case GrabState.PendingGrabbedBySelf:
                    grab = GetBehaviorByType<GrabbableBehavior>();
                    if(grab != null)
                    {
                        if(grab.GrabType == GrabbableBehavior.GrabTypes.ObjectFollowsHand)
                        {
                            // Request kinematic be true
                            _behaviorKinematicRequests.AddRequest(true, null, 0);
                            RefreshKinematic();
                            if(PhysicsFollower == null)
                            {
                                PhysicsFollower = SimplePool.Instance.Spawn(PhysicsFollowManager.Instance.PhysicsFollowPrefab).GetComponent<PhysicsFollowHand>();
                                PhysicsFollower.Init(this);
                            }
                        }else if (!BuildPlayManager.Instance.IsSpawnedInPlayMode)
                        {
                            // Grabbed in build mode, set to kinematic
                            // Request kinematic be true
                            _behaviorKinematicRequests.AddRequest(true, null, 0);
                            RefreshKinematic();
                        }
                        else
                        {
                            // In play mode, with non-ObjectFollow grab type, kinematic off
                            // Request kinematic be false
                            _behaviorKinematicRequests.AddRequest(false, null, 0);
                            RefreshKinematic();
                        }
                    }
                    else
                    {
                        // Grabbed without a grabbable, we must be in build mode
                        _behaviorKinematicRequests.AddRequest(true, null, 0);
                        RefreshKinematic();
                    }
                    break;
                case GrabState.GrabbedByOther:
                    grab = GetBehaviorByType<GrabbableBehavior>();
                    if(grab != null)
                    {
                        if(grab.GrabType == GrabbableBehavior.GrabTypes.ObjectFollowsHand)
                        {
                            rigidbody.isKinematic = true;
                        }else
                        {
                            // Check if the grabbing user is in build mode
                            if(UserManager.Instance.TryGetUserDisplay(GrabbingUser, out UserDisplay userDisplay))
                            {
                                if (!userDisplay.DRUserObj.IsInPlayMode)
                                    rigidbody.isKinematic = true;
                                else
                                    rigidbody.isKinematic = false;
                            } else
                                rigidbody.isKinematic = false;
                        }
                    }
                    else
                    {
                        // Grabbed without a grabbable, grabber must be in build mode
                        _behaviorKinematicRequests.AddRequest(true, null, 0);
                        RefreshKinematic();
                    }
                    // PhysicsFollower is only for local
                    if(PhysicsFollower != null)
                    {
                        PhysicsFollower.ResetState();
                        SimplePool.Instance.Despawn(PhysicsFollower.gameObject);
                        PhysicsFollower = null;
                    }
                    break;
            }
        }

        //switch (CurrentGrabState)
        //{
        //    case GrabState.Ungrabbed:
        //        SetChildrenColorTesting(Color.white);
        //        break;
        //    case GrabState.PendingGrabbedBySelf:
        //        SetChildrenColorTesting(Color.yellow);
        //        break;
        //    case GrabState.GrabbedBySelf:
        //        SetChildrenColorTesting(Color.green);
        //        break;
        //    case GrabState.PendingUngrabbed:
        //        SetChildrenColorTesting(Color.blue);
        //        break;
        //    case GrabState.GrabbedByOther:
        //        SetChildrenColorTesting(Color.red);
        //        break;
        //}
        //Debug.Log("Current owner: " + GetOwnerID());
        //if (GetOwnerID() == ushort.MaxValue)
        //{
        //    SetChildrenColorTesting(Color.white);
        //}
        //else if (GetOwnerID() == DarkRiftConnection.Instance.OurID)
        //{
        //    SetChildrenColorTesting(Color.green);
        //}
        //else
        //{
        //    SetChildrenColorTesting(Color.red);
        //}
    }
    public bool OnCanBeTransformed(Gizmo transformGizmo)
    {
        //Debug.LogWarning("On can be transformed!");
        //TODO this should return false if this is something that should not be edited
        // like, for example, someone else having it selected

        if (CurrentGrabState == GrabState.GrabbedByOther)
        {
            Debug.Log("Can't grab, someone else is");
            return false;
        }
        if (_drObject == null)
        {
            Debug.LogError("Can't be transformed, no DRObject!");
            return false;
        }

        //Debug.Log("Grabbed by: " + _drObject.GrabbedBy);
        return _drObject.GrabbedBy == DRObject.NoneGrabbing || _drObject.GrabbedBy == DarkRiftConnection.Instance.OurID;
    }
    public void OnTransformed(Gizmo transformGizmo)
    {
        //Debug.Log("Transformed by: " + transformGizmo.ActiveDragChannel);
        if (transformGizmo.ActiveDragChannel == GizmoDragChannel.None)
        {
            Debug.LogError("None for drag channel!?");
            return;
        }
        //TODO send out unreliable update
    }
    /// <summary>
    /// When VRBuildControls grabs this object
    /// Or when RLD begins transforming this object
    /// </summary>
    /// <returns></returns>
    public bool BuildSelect()
    {
        if (IsBuildEditing)
        {
            Debug.LogError("Can't build select twice on the same object " + Name, this);
            return false;
        }
        if(BuildGrabbable == null)
        {
            Debug.LogError("Can't build select, we have no BuildGrabbable!");
            return false;
        }
        if (CurrentGrabState != GrabState.GrabbedBySelf
            && CurrentGrabState != GrabState.PendingGrabbedBySelf
            && !TryGrab(BuildGrabbable))
        {
            Debug.LogWarning("Failed to build select, grab fail");
            return false;
        }
        IsBuildEditing = true;
        //Debug.Log("Build select!");
        //Debug.Log("Will set to layer " + Layer);
        // Update the layer, which should now be build select
        RefreshLayer();
        BuildGrabbable.SetColliderOn(!IsBuildEditing);
        return true;
    }
    public void EndBuildSelect(bool networkChange=true, GizmoDragChannel dragChannel=GizmoDragChannel.PositionRotation)
    {
        // TODO the default end build select should probably only send out what changed, and should handle scale if
        // it changed
        if (!IsBuildEditing)
        {
            Debug.LogError("Can't end build select we're not build selected " + Name, this);
            return;
        }
        IsBuildEditing = false;
        //Debug.Log("End Build select! channel " + dragChannel + " pos " + transform.localPosition);
        //Debug.Log("End build select will set to layer " + Layer);
        RefreshLayer();
        if(BuildGrabbable != null)
            BuildGrabbable.SetColliderOn(!IsBuildEditing);

        if (MovingPlatformBehavior != null)
            MovingPlatformBehavior.ForceUpdateFromTransform();

        if (!networkChange)
            return;

        //TODO maybe drop this if we weren't grabbing
        if (dragChannel == GizmoDragChannel.Offset)
            DarkRiftConnection.Instance.UpdateReliablePosition(_drObject, transform.localPosition);
        //else if (dragChannel == GizmoDragChannel.Rotation)
            //DarkRiftConnection.Instance.UpdateReliableRotation(_drObject, transform.localRotation);
        else if (dragChannel == GizmoDragChannel.Scale)
            DarkRiftConnection.Instance.UpdateReliableScale(_drObject, transform.localScale);
        else if (dragChannel == GizmoDragChannel.PositionRotation
            || dragChannel == GizmoDragChannel.Rotation) // Rotation also changes position
            DarkRiftConnection.Instance.UpdateReliablePositionRotation(_drObject, transform.localPosition, transform.localRotation);
        else
            Debug.LogError("Unhandled drag channel " + dragChannel);

        // End grab if we're still grabbing
        if(CurrentGrabState == GrabState.PendingGrabbedBySelf
            || CurrentGrabState == GrabState.GrabbedBySelf)
            EndGrab();
    }
    public void OnDragBegin(GizmoDragChannel transformGizmo)
    {
        //Debug.Log("Drag begin!");
        BuildSelect();
    }
    public void OnDragEnd(GizmoDragChannel gizmoType)
    {
        //Debug.Log("Drag end!");
        EndBuildSelect(true, gizmoType);
    }
    public void OnServerUpdateGrabPhysicsPosRotVel(DarkRiftReader reader, ushort grabberID, out byte grabbingBodyPart, out Vector3 grabPos, out Quaternion grabRot,
        out Vector3 velWorld, out Vector3 angVelWorld)
    {
        // Deserialize the message
        DRObject.DeserializeGrabPhysicsPosRotVel(reader, out grabbingBodyPart,
            out grabPos, out grabRot, out velWorld, out angVelWorld);

        // We allow this message if this object is grabbed by the grabber, or if it's ungrabbed
        if(_drObject.GrabbedBy != grabberID && _drObject.GrabbedBy != ushort.MaxValue)
        {
            Debug.LogWarning("Dropping grab physics update, grabbed by " + _drObject.GrabbedBy + " req from " + grabberID);
            return;
        }

        // This is only valid for grabbed objects with physics, so we let NetworkObject do the deserialization
        if (NetObj != null)
            NetObj.ServerSentGrabPhysicsUpdate(grabberID, grabbingBodyPart, grabPos, grabRot, velWorld, angVelWorld);
        else
        {
            Debug.LogError("Failed to handle GrabPhysics update, no NetworkObject!");
        }
    }
    public void OnServerUpdatePosition(DarkRiftReader reader, bool forceToRest)
    {
        _drObject.DeserializePos(reader);
        Vector3 pos = _drObject.Position.ToVector3();
        // Update the position. If we have a network object
        // use it to interpolate the position. Otherwise,
        // update immediately
        if (NetObj != null)
            NetObj.ServerSentPosition(pos, forceToRest);
        else
            transform.localPosition = pos;
        //Debug.Log("Deserialized pos to " + transform.localPosition);
    }
    public void OnServerUpdateRotation(DarkRiftReader reader, bool isForceRest)
    {
        _drObject.DeserializeRot(reader);
        Quaternion rot = _drObject.Rotation.ToQuaternion();
        if (NetObj != null)
            NetObj.ServerSentRotation(rot, isForceRest);
        else
            transform.localRotation = rot;
    }
    public void OnServerUpdateVelocity(DarkRiftReader reader)
    {
        _drObject.DeserializeVelocity(reader);
        Vector3 vel = _drObject.Velocity.ToVector3();
        if (NetObj != null)
            NetObj.ServerSentVelocity(vel);
        else
            Debug.LogError("Velocity update, but we have no NetworkObject!");
    }
    public void OnServerUpdateAngularVelocity(DarkRiftReader reader)
    {
        _drObject.DeserializeAngularVelocity(reader);
        Vector3 angVel = _drObject.AngularVelocity.ToVector3();
        if (NetObj != null)
            NetObj.ServerSentAngularVelocity(angVel);
        else
            Debug.LogError("Angular Velocity update, but we have no NetworkObject!");
    }
    public void OnServerUpdateScale(DarkRiftReader reader)
    {
        _drObject.DeserializeScale(reader);
        transform.localScale = _drObject.Scale.ToVector3();
    }
    public void OnServerUpdateAtRest(bool atRest)
    {
        _drObject.SetAtRest(atRest);
        if (NetObj != null)
            NetObj.ServerSentForceRest(atRest);
    }
    public bool CanGrab(bool debugReason=false)
    {
        //TODO THIS WILL BREAK IF THE USER LEAVES WHEN GRABBING
        if (CurrentGrabState == GrabState.GrabbedByOther)
        {
            if(debugReason)
                Debug.Log("Can't grab " + _drObject.GetID() + " we're grabbed by other");
            return false;
        }
        if (CurrentGrabState == GrabState.PendingGrabbedBySelf)
        {
            //if(debugReason)
            //Debug.Log("Can't grab " + _drObject.GetID() + " we're grabbed by self");
            //return false;
            return true;
        }
        if (CurrentGrabState == GrabState.PendingGrabbedBySelf)
        {
            //if(debugReason)
                //Debug.Log("Can't grab " + _drObject.GetID() + " we're pending grabbed by self");
            //return false;
            return true;
        }
        if (_drObject == null)
        {
            if(debugReason)
                Debug.LogError("Can't grab no dr object!");
            return false;
        }
        if (_drObject.GrabbedBy != DRObject.NoneGrabbing && CurrentGrabState != GrabState.PendingUngrabbed)
        {
            if(debugReason)
                Debug.LogError("Can't grab, obj says grabbed by " + _drObject.GrabbedBy);
            return false;
        }
        return true;
    }
    public bool TryGrab(BaseGrabbable baseGrabbable)
    {
        if (!CanGrab(true))
            return false;
        //Debug.Log("Will now grab");
        // Grab this object
        DarkRiftConnection.Instance.TryGrabObject(_drObject, baseGrabbable.GrabbedBodyPart, baseGrabbable.RelPos, baseGrabbable.RelRot);

        Debug.Log(CurrentGrabState + "->" + GrabState.PendingGrabbedBySelf);
        CurrentGrabState = GrabState.PendingGrabbedBySelf;
        ConfigureForGrabState();
        RefreshLayer();
        return true;
    }
    public void EndGrab()
    {
        if (CurrentGrabState != GrabState.GrabbedBySelf
            && CurrentGrabState != GrabState.PendingGrabbedBySelf) // GrabState will be pending if we quickly click something
        {
            Debug.LogError("Wrong grab state in end grab! we have " + CurrentGrabState);
            return;
        }
        Debug.Log("Will release grab");
        // Ungrab the object
        DarkRiftConnection.Instance.ReleaseGrab(_drObject);
        //Debug.Log(CurrentGrabState + "->" + GrabState.PendingUngrabbed);
        CurrentGrabState = GrabState.PendingUngrabbed;
        ConfigureForGrabState();
        RefreshLayer();

    }
    public static GrabState GrabberID2GrabState(ushort grabber)
    {
        if (grabber == DRObject.NoneGrabbing)
            return GrabState.Ungrabbed;
        else if (grabber == DarkRiftConnection.Instance.OurID)
            return GrabState.GrabbedBySelf;
        else
            return GrabState.GrabbedByOther;
    }
    public void UpdateGrabState(ushort grabber, uint timeReleased)
    {
        GrabState newGrabState = GrabberID2GrabState(grabber);
        // If we go from grab-> ungrab quickly we should end in state ungrab
        if (CurrentGrabState == GrabState.PendingUngrabbed && newGrabState == GrabState.GrabbedBySelf)
        {
            Debug.LogWarning("Dropping grab message, because we're in " + CurrentGrabState);
            return;
        }

        _drObject.GrabbedBy = grabber;
        if (grabber != DRObject.NoneGrabbing)
        {
            ushort prevOwner = _drObject.OwnerID;
            _drObject.OwnerID = grabber;
            if (OnOwnershipChange != null)
                OnOwnershipChange(prevOwner, grabber);
            InvokeEventOnBehaviors(OnOwnerChangeStrVal);
        }
        if (grabber == DRObject.NoneGrabbing)
            _drObject.OwnershipTime = timeReleased; // Ownership time is only used when there's no grabber

        // Handle if we tried and failed to grab;
        if(newGrabState == GrabState.GrabbedByOther)
        {
            if(IsBuildEditing)
            {
                Debug.Log("Someone grabbed before we could build grab");
                EndBuildSelect(false);
            }
            if (CurrentGrabState == GrabState.PendingGrabbedBySelf
                || CurrentGrabState == GrabState.GrabbedBySelf)
            {
                // Tell controller abstraction that we're no longer going to be grabbing this
                // object
                for (int i = 0; i < ControllerAbstraction.NumControllerTypes; i++)
                {
                    var inst = ControllerAbstraction.Instances[i];
                    if (inst.CurrentGrabbed == null || inst.CurrentGrabbed.GetSceneObject() != this)
                        continue;
                    Debug.Log("Force ungrabbing in controller abstraction, someone else is grabbing");
                    inst.ForceUngrab();
                }
            }
        }
        // If we were still pending grab, then notify UserHandGrabbedDisplay
        // that this is no longer an anticipated grab
        if(CurrentGrabState == GrabState.PendingGrabbedBySelf
            && newGrabState == GrabState.GrabbedByOther)
            UserManager.Instance.LocalUserDisplay.PoseDisplay.HandDisplay.AnticipateReleasingObject(this);

        // If we're grabbing, or pending grabbing, we should only
        // update our state if the new state is someone else grabbing
        // This is because if we grab->ungrab->grab we might receive the
        // ungrab message while we're still pending grab
        if (newGrabState == GrabState.Ungrabbed
            && (CurrentGrabState == GrabState.PendingGrabbedBySelf || CurrentGrabState == GrabState.GrabbedBySelf)
            && DarkRiftConnection.Instance.GetLastSentGrabState(_drObject.GetID()) == DarkRiftConnection.Instance.OurID)
        {
            Debug.LogWarning("Dropping ungrab message because we last requested to grab. In state: " + CurrentGrabState);
            return;
        }

        //Debug.Log(CurrentGrabState + "->" + newGrabState);
        CurrentGrabState = newGrabState;
        ConfigureForGrabState();
        RefreshLayer();
    }
    public void DeserializeBehaviors(DRObject dRObject)
    {
        if (dRObject.DRBehaviors == null)
            return;

        foreach (SerializedBehavior serializedBehavior in dRObject.DRBehaviors)
        {
            BaseBehavior existingBehavior = GetBehaviorWithID(serializedBehavior.IsUserScript, serializedBehavior.BehaviorID);
            if (existingBehavior != null)
            {
                Debug.Log("We already have behavior " + serializedBehavior.BehaviorID + " networked: " + serializedBehavior.IsUserScript);
                existingBehavior.SetSerializedBehavior(serializedBehavior, true);
                continue;
            }
            BehaviorInfo behaviorData;
            if (serializedBehavior.IsUserScript)
                behaviorData = UserScriptManager.Instance.GetBehaviorInfoFromID(serializedBehavior.BehaviorID);
            else
                behaviorData = CSharpBehaviorManager.Instance.GetBehaviorInfoFromID(serializedBehavior.BehaviorID);

            if (behaviorData == null)
            {
                Debug.LogWarning("Behavior not found for " + serializedBehavior.BehaviorID);
                continue;
            }
            BaseBehavior behavior = AddBehavior(behaviorData, false, false, serializedBehavior);
        }
        // Make sure that we don't have a rigidbody if we don't need it
        if(Rigidbody != null && !DoesAnyAttachedBehaviorRequireRigidbody())
        {
            Destroy(Rigidbody);
            Rigidbody = null;
        }
        // Make sure that we don't have a NetworkObject if we don't need it
        if(NetObj != null && !IsTransformNetworked)
        {
            Debug.Log("Removing NetworkObject from DeserializeBehaviors");
            Destroy(NetObj);
            NetObj = null;
        }
    }
    private BaseBehavior GetAttachedBehavior(bool isBehaviorNetworkScript, ushort behaviorID)
    {
        for (int i = 0; i < _attachedBehaviors.Count; i++)
        {
            BaseBehavior behavior = _attachedBehaviors[i];
            BehaviorInfo behaviorInfo = behavior.GetBehaviorInfo();
            if (behaviorInfo.IsNetworkedScript() != isBehaviorNetworkScript
                || behaviorInfo.BehaviorID != behaviorID)
                continue;
            return behavior;
        }
        return null;
    }
    public T GetBehaviorByType<T>() where T : BaseBehavior
    {
        // TODO we can speed this up for builtin methods by just
        // using the behavior ID
        for(int i = 0; i < _attachedBehaviors.Count; i++)
        {
            T candidate = _attachedBehaviors[i] as T;
            if (candidate != null)
                return candidate;
        }
        return null;
    }
    public void OnBehaviorAdded(SerializedBehavior serializedBehavior)
    {
        // If we added a behavior, the server will echo it back
        // to say that adding it was effective.
        // this is needed for the SerializedBehavior to know
        // what data is still pending, and what has been ACK'd
        if (!_drObject.AddBehavior(serializedBehavior))
        {
            //BaseBehavior behavior = GetAttachedBehavior(serializedBehavior.IsBehaviorNetworked, serializedBehavior.BehaviorID);
            //if(behavior == null)
                //Debug.LogWarning("DRObject said we had behavior, but no such behavior attached! C#:" + serializedBehavior.IsBehaviorNetworked + " #" + serializedBehavior.BehaviorID);
            return;
        }

        BehaviorInfo behaviorData;
        if (serializedBehavior.IsUserScript)
            behaviorData = UserScriptManager.Instance.GetBehaviorInfoFromID(serializedBehavior.BehaviorID);
        else
            behaviorData = CSharpBehaviorManager.Instance.GetBehaviorInfoFromID(serializedBehavior.BehaviorID);
        if(behaviorData == null)
        {
            Debug.LogWarning("Behavior not found for " + serializedBehavior.BehaviorID + " networked: " + serializedBehavior.IsUserScript);
            return;
        }
        BaseBehavior baseBehavior = AddBehavior(behaviorData, false, false, serializedBehavior);
        // Update the UI, if this is selected
        if (PropertiesAndBehaviors.Instance != null && PropertiesAndBehaviors.Instance.SelectedObject == this)
            PropertiesAndBehaviors.Instance.RefreshComponent(baseBehavior);
    }
    public void OnBehaviorUpdate(bool isBehaviorNetworkScript, bool hasFlags, ushort behaviorID, DarkRiftReader reader)
    {
        BaseBehavior behavior = GetAttachedBehavior(isBehaviorNetworkScript, behaviorID);
        if(behavior == null)
        {
            Debug.LogWarning("Can't handle behavior update for " + behaviorID + " not found!");
            return;
        }
        // Update the serialized copy of the data, to match the server
        behavior.GetSerializedObject().UpdateParamsFromUpdate(reader, hasFlags, null, null);
        // Tell the behavior to re-read it's properties from the serialized version
        behavior.UpdateParamsFromSerializedObject();
        // Notify the behavior that it's parameters changed, as a result of the server
        behavior.OnPropertiesChange(false, false);
        // Update the UI, if this is selected
        if (PropertiesAndBehaviors.Instance != null && PropertiesAndBehaviors.Instance.SelectedObject == this)
            PropertiesAndBehaviors.Instance.RefreshComponent(behavior);
    }
    public void OnBehaviorRemoved(bool wasBehaviorNetworked, ushort serializedBehaviorID)
    {
        if (!_drObject.RemoveBehavior(wasBehaviorNetworked, serializedBehaviorID))
            return;// This happens when the server tells us that we removed a behavior
        // Get the behavior instance for this removed behavior
        for(int i = 0; i < _attachedBehaviors.Count; i++)
        {
            BaseBehavior behavior = _attachedBehaviors[i];
            BehaviorInfo info = behavior.GetBehaviorInfo();
            if (info.IsNetworkedScript() != wasBehaviorNetworked
                || info.BehaviorID != serializedBehaviorID)
                continue;
            // Remove that behavior (this will update the UI)
            RemoveBehavior(behavior, false);
            return;
        }
        Debug.LogError("No matching IBehavior for ID #" + serializedBehaviorID + " on obj " + _drObject.GetID());
    }
    public void OnAttachedScriptUpdated(BaseBehavior baseBehavior)
    {
        // We re-evaluate if we need networking for this object
        bool behaviorsRequireNetworking = DoesAnyAttachedBehaviorRequireNetworking();

        if (IsTransformNetworked)
        {
            if (!behaviorsRequireNetworking)
                RemoveNetworking();
        }
        else
        {
            if (behaviorsRequireNetworking)
                AddNetworking();
        }
    }
    public BaseBehavior GetBehaviorWithID(bool isBehaviorNetworked, ushort behaviorID)
    {
        for(int i = 0; i < _attachedBehaviors.Count; i++)
        {
            var behavior = _attachedBehaviors[i];
            BehaviorInfo info = behavior.GetBehaviorInfo();
            if (info.IsNetworkedScript() == isBehaviorNetworked
                && info.BehaviorID == behaviorID)
                return behavior;
        }
        return null;
    }
    public List<ExposedVariable> GetAllExposedVariables()
    {
        _exposedVariables.Clear();
        foreach(BaseBehavior baseBehavior in _attachedBehaviors)
        {
            var vars = baseBehavior.GetVariables();
            if (vars == null)
                continue;
            _exposedVariables.AddRange(vars);
        }
        // Add vars from SceneObject
        GetAllSceneObjectExposedVariables(_alwaysExposedVariables, this);
        _exposedVariables.AddRange(_alwaysExposedVariables);
        return _exposedVariables;
    }
    public List<ExposedFunction> GetAllAvailableUserFunctions()
    {
        _exposedFunctions.Clear();
        foreach(BaseBehavior baseBehavior in _attachedBehaviors)
        {
            var functions = baseBehavior.GetFunctions();
            if (functions == null)
                continue;
            _exposedFunctions.AddRange(functions);
        }
        // Add functions from SceneObject
        _exposedFunctions.AddRange(_alwaysExposedFunctions);
        // add the scene level functions
        var alwaysFuncs = UserScriptManager.Instance.GetAllAlwaysExposedFunctions();
        _exposedFunctions.AddRange(alwaysFuncs);
        return _exposedFunctions;
    }
    public List<ExposedEvent> GetAllExposedEvents()
    {
        _exposedEvents.Clear();
        foreach(BaseBehavior baseBehavior in _attachedBehaviors)
        {
            var events = baseBehavior.GetEvents();
            if (events == null)
                continue;
            _exposedEvents.AddRange(events);
        }
        // Add events from SceneObject
        GetAllSceneObjectExposedEvents(_alwaysExposedEvents);
        _exposedEvents.AddRange(_alwaysExposedEvents);
        // add the scene level events
        var alwaysEvents = UserScriptManager.Instance.GetAllAlwaysExposedEvents();
        _exposedEvents.AddRange(alwaysEvents);
        return _exposedEvents;
    }
    public static void GetAllSceneObjectExposedVariables(List<ExposedVariable> exposedVariables, SceneObject sceneObject=null)
    {
        if(exposedVariables.Count == 0)
        {
            exposedVariables.Add(new ExposedVariable(ValString.nameStr, "The current name of this object", sceneObject?.Name));
            // TODO it'd probably be better to just have a transform variable
            exposedVariables.Add(new ExposedVariable(ValString.positionStr, "The current position of this object", sceneObject != null ? sceneObject.transform.localPosition : Vector3.zero));
            exposedVariables.Add(new ExposedVariable(ValString.rotationStr, "The current rotation of this object", sceneObject != null ? sceneObject.transform.localRotation : Quaternion.identity));
            exposedVariables.Add(new ExposedVariable(ScaleVal, "The current scale of this object", sceneObject != null ? sceneObject.transform.localScale : Vector3.one));
            exposedVariables.Add(new ExposedVariable(ValString.forwardStr, "The forward direction (blue arrow) of this object", sceneObject != null ? sceneObject.transform.forward : Vector3.zero));
            exposedVariables.Add(new ExposedVariable(ValString.rightStr, "The right direction (red arrow) of this object", sceneObject != null ? sceneObject.transform.right : Vector3.zero));
            //TODO move these to UserScriptManager
            exposedVariables.Add(new ExposedVariable(ValString.timeStr, "Time in seconds since the user opened this app", TimeManager.Instance.RenderTime));
            exposedVariables.Add(new ExposedVariable(ValString.deltaTimeStr, "How long in seconds the last frame took", TimeManager.Instance.RenderDeltaTime));
            exposedVariables.Add(new ExposedVariable(FixedTimeStrVal, "How long in seconds the last physics frame took", TimeManager.Instance.PhysicsTimestep));
            exposedVariables.Add(new ExposedVariable(ValString.frameCountStr, "How many frames have been run on this device", Time.frameCount));
            return;
        }
        int i = 0;
        exposedVariables[i++].SetString(sceneObject?.Name);
        exposedVariables[i++].SetVector3(sceneObject != null ? sceneObject.transform.localPosition : Vector3.zero);
        exposedVariables[i++].SetQuaternion(sceneObject != null ? sceneObject.transform.localRotation : Quaternion.identity);
        exposedVariables[i++].SetVector3(sceneObject != null ? sceneObject.transform.localScale : Vector3.one);
        exposedVariables[i++].SetVector3(sceneObject != null ? sceneObject.transform.forward : Vector3.zero);
        exposedVariables[i++].SetVector3(sceneObject != null ? sceneObject.transform.right : Vector3.zero);
        exposedVariables[i++].SetNumber(TimeManager.Instance.RenderTime);
        exposedVariables[i++].SetNumber(TimeManager.Instance.RenderDeltaTime);
        exposedVariables[i++].SetNumber(TimeManager.Instance.PhysicsTimestep);
        exposedVariables[i++].SetNumber(Time.frameCount);
    }
    public static List<ExposedFunction> GetAllSceneObjectExposedFunctions()
    {
        return _alwaysExposedFunctions;
    }
    public static void GetAllSceneObjectExposedEvents(List<ExposedEvent> exposedEvents)
    {
        if(exposedEvents.Count == 0)
        {
            exposedEvents.Add(new ExposedEvent(OnOwnerChangeStrVal, "When the person in charge of simulating changes", null));
        }
    }
    public void InvokeEventOnBehaviors(ValString eventName)
    {
        foreach(BaseBehavior baseBehavior in _attachedBehaviors)
        {
            UserScriptBehavior userScriptBehavior = baseBehavior as UserScriptBehavior;
            if(userScriptBehavior == null)
                continue;
            userScriptBehavior.InvokeEvent(eventName);
        }
    }
    public static SceneObject FromDRObject(DRObject dRObject, Transform parent)
    {
        GameObject newObj = new GameObject(dRObject.GetID().ToString());
        newObj.transform.SetParent(parent);
        //newObj.transform.localPosition = DefPos;

        SceneObject newSceneObject = newObj.AddComponent<SceneObject>();

        newSceneObject.Init(dRObject, false, false);
        // Deserialize all transform info
        newSceneObject.transform.localPosition = dRObject.Position.ToVector3();
        newSceneObject.transform.localRotation = dRObject.Rotation.ToQuaternion();
        newSceneObject.transform.localScale = dRObject.Scale.ToVector3();
        // Deserialize all the behaviors
        newSceneObject.DeserializeBehaviors(dRObject);

        return newSceneObject;
    }
    public void SetEnabled(bool enabled, bool updateServer)
    {
        if (Model != null)
            Model.SetActive(enabled);
        for(int i = 0; i < _attachedBehaviors.Count; i++)
            _attachedBehaviors[i].enabled = enabled;
        if (_placeholderBox != null)
            _placeholderBox.SetActive(enabled);
        if (AABBCollider != null)
            AABBCollider.gameObject.SetActive(enabled);
        IsEnabled = enabled;

        if(updateServer)
            DarkRiftConnection.Instance.ObjectEnableChange(_drObject, enabled);
    }
    public static void InitializeMiniscriptIntrinsics()
    {
        if (_hasLoadedIntrinsics)
            return;
        _hasLoadedIntrinsics = true;
        Intrinsic intrinsic;
        intrinsic = Intrinsic.Create("AmIObjectOwner");
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
                return Intrinsic.Result.Null;

            bool doWeOwn = sceneObject.DoWeOwn;
            return doWeOwn ? new Intrinsic.Result(ValNumber.one) : new Intrinsic.Result(ValNumber.zero);
		};
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Is the client in charge of simulating this object?", "amOwner"));

        intrinsic = Intrinsic.Create("Move");
        intrinsic.AddParam("x", 0.0);
        intrinsic.AddParam("y", 0.0);
        intrinsic.AddParam("z", 0.0);
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
                return Intrinsic.Result.Null;
            ValNumber xVal = context.GetVar("x") as ValNumber;
            if (xVal == null)
                return Intrinsic.Result.Null;
            ValNumber yVal = context.GetVar("y") as ValNumber;
            if (yVal == null)
                return Intrinsic.Result.Null;
            ValNumber zVal = context.GetVar("z") as ValNumber;
            if (zVal == null)
                return Intrinsic.Result.Null;

            Rigidbody r = sceneObject.Rigidbody;
            if(r != null)
            {
                Vector3 newPos = new Vector3((float)xVal.value, (float)yVal.value, (float)zVal.value) + r.position;
                r.MovePosition(newPos);
            }
            else
            {
                sceneObject.transform.Translate(new Vector3((float)xVal.value, (float)yVal.value, (float)zVal.value), Space.Self);
            }
            return new Intrinsic.Result(ValNumber.one);
		};
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Moves the object by a distance", null));

        intrinsic = Intrinsic.Create("SetPosition");
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Instantly move the object to a new position. Optional flag to network the change", null));
        intrinsic.AddParam("x", 0.0);
        intrinsic.AddParam("y", 0.0);
        intrinsic.AddParam("z", 0.0);
        intrinsic.AddParam(NetworkChangeVal.value);
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
            {
                UserScriptManager.LogToCode(context, "No SceneObject for SetPosition call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            var vecType = UserScriptManager.ParseVecInput(
                context.GetVar(ValString.xStr),
                context.GetVar(ValString.yStr),
                context.GetVar(ValString.zStr),
                null,
                out double xVal, out Vector2 vec2, out Vector3 vec3, out Quaternion rot);
            if(vecType != UserScriptManager.VecType.Vector3)
            {
                UserScriptManager.LogToCode(context, "Bad input for SetPosition call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }

            if (sceneObject.PhysicsFollower != null)
                sceneObject.PhysicsFollower.OurRigidbody.MovePosition(vec3);
            if (sceneObject.Rigidbody != null)
                sceneObject.Rigidbody.MovePosition(vec3);
            else
                sceneObject.transform.localPosition = vec3;

            ValNumber networkNum = context.GetVar(NetworkChangeVal) as ValNumber;
            bool network = networkNum != null && networkNum.BoolValue();
            if (network)
                DarkRiftConnection.Instance.UpdateReliablePosition(sceneObject._drObject, sceneObject.transform.localPosition);

            return Intrinsic.Result.True;
		};

        intrinsic = Intrinsic.Create("SetScale");
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Change how large the object is, with an optional flag to network the change", null));
        intrinsic.AddParam("x");
        intrinsic.AddParam("y");
        intrinsic.AddParam("z");
        intrinsic.AddParam(NetworkChangeVal.value);
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
            {
                UserScriptManager.LogToCode(context, "No SceneObject for SetScale call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            var vecType = UserScriptManager.ParseVecInput(
                context.GetVar(ValString.xStr),
                context.GetVar(ValString.yStr),
                context.GetVar(ValString.zStr),
                null,
                out double xVal, out Vector2 vec2, out Vector3 vec3, out Quaternion rot);
            if(vecType != UserScriptManager.VecType.Vector3)
            {
                UserScriptManager.LogToCode(context, "Bad input for SetScale call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }

            //Debug.Log("Set scale to " + vec3 + " for " + sceneObject.name);
            sceneObject.transform.localScale = vec3;

            ValNumber networkNum = context.GetVar(NetworkChangeVal) as ValNumber;
            bool network = networkNum == null || !networkNum.BoolValue();
            if (network)
                DarkRiftConnection.Instance.UpdateReliableScale(sceneObject._drObject, vec3);

            return Intrinsic.Result.True;
		};

        intrinsic = Intrinsic.Create("TransformPoint");
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Convert a local-space position to a world-space position", null));
        intrinsic.AddParam("x", 0.0);
        intrinsic.AddParam("y", 0.0);
        intrinsic.AddParam("z", 0.0);
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
            {
                UserScriptManager.LogToCode(context, "No SceneObject for TransformPoint call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            var vecType = UserScriptManager.ParseVecInput(
                context.GetVar(ValString.xStr),
                context.GetVar(ValString.yStr),
                context.GetVar(ValString.zStr),
                null,
                out double xVal, out Vector2 vec2, out Vector3 vec3, out Quaternion rot);
            if(vecType != UserScriptManager.VecType.Vector3)
            {
                UserScriptManager.LogToCode(context, "Bad input for TransformPoint call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }

            return new Intrinsic.Result(new ValVector3(sceneObject.transform.TransformPoint(vec3)));
		};

        intrinsic = Intrinsic.Create("Rotate");
        intrinsic.AddParam("x", 0.0);
        intrinsic.AddParam("y", 0.0);
        intrinsic.AddParam("z", 0.0);
        intrinsic.AddParam("w");
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Rotates the object by some degrees around it's center", null));
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
            {
                UserScriptManager.LogToCode(context, "No SceneObject for SetRotation call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            var vecType = UserScriptManager.ParseVecInput(
                context.GetVar(ValString.xStr),
                context.GetVar(ValString.yStr),
                context.GetVar(ValString.zStr),
                context.GetVar(ValString.wStr),
                out double xVal, out Vector2 vec2, out Vector3 vec3, out Quaternion rot);
            // Vector 3 can be interpreted as euler
            if(vecType == UserScriptManager.VecType.Vector3)
                rot = Quaternion.Euler(vec3);
            else if(vecType != UserScriptManager.VecType.Quaternion)
            {
                UserScriptManager.LogToCode(context, "Bad input for SetRotation call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            //TODO rotate around local vs global
            rot = rot * sceneObject.transform.localRotation;

            if (sceneObject.PhysicsFollower != null)
                sceneObject.PhysicsFollower.OurRigidbody.MoveRotation(rot);
            if (sceneObject.Rigidbody != null)
                sceneObject.Rigidbody.MoveRotation(rot);
            else
                sceneObject.transform.localRotation = rot;
            return Intrinsic.Result.True;
		};
        intrinsic = Intrinsic.Create("RotateAround");
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Rotates the object by some degrees around a point/axis", null));
        intrinsic.AddParam(PointStrVal.value);
        intrinsic.AddParam(AxisStrVal.value);
        intrinsic.AddParam(AngleStrVal.value);
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
            {
                UserScriptManager.LogToCode(context, "No SceneObject for SetRotation call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            ValVector3 ptVec = context.GetVar(PointStrVal) as ValVector3;
            if(ptVec == null)
            {
                UserScriptManager.LogToCode(context, "No point for RotateAround call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            ValVector3 axisVec = context.GetVar(AxisStrVal) as ValVector3;
            if(axisVec == null)
            {
                UserScriptManager.LogToCode(context, "No axis for RotateAround call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            ValNumber angleNum = context.GetVar(AngleStrVal) as ValNumber;
            if(angleNum == null)
            {
                UserScriptManager.LogToCode(context, "No angle for RotateAround call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }

            //TODO rotate around local vs global

            Rigidbody rb = sceneObject.Rigidbody;
            Vector3 pos;
            Quaternion rot;
            if (rb == null)
            {
                sceneObject.transform.RotateAround(ptVec.Vector3, axisVec.Vector3, angleNum.FloatValue());
                pos = sceneObject.transform.position;
                rot = sceneObject.transform.rotation;
            }
            else
            {
                sceneObject.transform.SimulateRotateAround(ptVec.Vector3, axisVec.Vector3, angleNum.FloatValue(), out pos, out rot);
                //TODO allow force/velocity via param

                Vector3 vel = (pos - sceneObject.transform.position) / TimeManager.Instance.PhysicsTimestep;
                Vector3 angVel = ExtensionMethods.GetAngularVelocity(sceneObject.transform.rotation, rot, TimeManager.Instance.PhysicsTimestep);
                rb.velocity = vel;
                rb.angularVelocity = angVel;
            }

            if (sceneObject.PhysicsFollower != null)
            {
                sceneObject.PhysicsFollower.OurRigidbody.MovePosition(pos);
                sceneObject.PhysicsFollower.OurRigidbody.MoveRotation(rot);
            }
            return Intrinsic.Result.True;
		};

        intrinsic = Intrinsic.Create("SetRotation");
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Instantly move the object to a new rotation. Either pass xyzw for a full quaternion, or xyz to pass an euler", null));
        intrinsic.AddParam("x", 0.0);
        intrinsic.AddParam("y", 0.0);
        intrinsic.AddParam("z", 0.0);
        intrinsic.AddParam("w");
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
            {
                UserScriptManager.LogToCode(context, "No SceneObject for SetRotation call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            var vecType = UserScriptManager.ParseVecInput(
                context.GetVar(ValString.xStr),
                context.GetVar(ValString.yStr),
                context.GetVar(ValString.zStr),
                context.GetVar(ValString.wStr),
                out double xVal, out Vector2 vec2, out Vector3 vec3, out Quaternion rot);
            // Vector 3 can be interpreted as euler
            if(vecType == UserScriptManager.VecType.Vector3)
                rot = Quaternion.Euler(vec3);
            else if(vecType != UserScriptManager.VecType.Quaternion)
            {
                UserScriptManager.LogToCode(context, "No bad input for SetRotation call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            if (sceneObject.PhysicsFollower != null)
                sceneObject.PhysicsFollower.OurRigidbody.MoveRotation(rot);
            if (sceneObject.Rigidbody != null)
                sceneObject.Rigidbody.MoveRotation(rot);
            else
                sceneObject.transform.localRotation = rot;
            return Intrinsic.Result.True;
		};

        intrinsic = Intrinsic.Create("SetPositionRotation");
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Convenience method for setting both position and rotation. Pass this a map with 'position' and 'rotation' keys", null));
        intrinsic.AddParam("position", 0.0);
        intrinsic.AddParam("rotation", 0.0);
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
            {
                UserScriptManager.LogToCode(context, "No SceneObject for SetPositionRotation call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            if(!UserScriptManager.ParsePositionRotation(context.GetVar(ValString.positionStr), context.GetVar(ValString.rotationStr), out Vector3 pos, out Quaternion rot))
            {
                UserScriptManager.LogToCode(context, "Bad input for SetPositionAndRotation!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }

            // set position
            if (sceneObject.PhysicsFollower != null)
                sceneObject.PhysicsFollower.OurRigidbody.MovePosition(pos);
            if (sceneObject.Rigidbody != null)
                sceneObject.Rigidbody.MovePosition(pos);
            else
                sceneObject.transform.localPosition = pos;
            // set rotation
            if (sceneObject.PhysicsFollower != null)
                sceneObject.PhysicsFollower.OurRigidbody.MoveRotation(rot);
            if (sceneObject.Rigidbody != null)
                sceneObject.Rigidbody.MoveRotation(rot);
            else
                sceneObject.transform.localRotation = rot;
            return Intrinsic.Result.True;
		};

        intrinsic = Intrinsic.Create("SetColor");
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Sets the color of the object. Pass a known color name, or an HTML color string", null));
        intrinsic.AddParam("color");
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
            {
                UserScriptManager.LogToCode(context, "No SceneObject for SetColor call!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            if(!UserScriptManager.ParseColorInput(context.GetVar("color"), out Color color))
            {
                UserScriptManager.LogToCode(context, "Bad input for SetColor!", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }

            //var sceneMats = sceneObject.SceneMaterials;
            //if (sceneMats == null)
            //{
            //    UserScriptManager.LogToCode(context, "SceneObject can't SetColor, no scene materials", UserScriptManager.CodeLogType.Warning);
            //    return Intrinsic.Result.Null;
            //}

            //for (int i = 0; i < sceneMats.Length; i++)
            //    sceneMats[i]?.SetColor(0, color, true, false);

            //if (sceneObject.IsLoadingModel)
            //{
            //    UserScriptManager.LogToCode(context, "SceneObject can't SetColor, loading model", UserScriptManager.CodeLogType.Warning);
            //    return Intrinsic.Result.Null;
            //}

            //GameObject obj = sceneObject.Model;
            //if (obj == null)
            //{
            //    UserScriptManager.LogToCode(context, "SceneObject can't SetColor, null model", UserScriptManager.CodeLogType.Warning);
            //    return Intrinsic.Result.Null;
            //}

            // TODO
            Renderer[] rends = sceneObject.Model.GetComponentsInChildren<Renderer>();
            for (int i = 0; i < rends.Length; i++)
                rends[i].material.SetColor(color);
            Renderer rend = sceneObject.Model.GetComponent<Renderer>();
            if(rend != null)
                rend.material.SetColor(color);
            //Renderer rend = obj.GetComponent<Renderer>();
            //rend.material.color = color;
            return Intrinsic.Result.True;
		};

        intrinsic = Intrinsic.Create("AddScript");
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Adds a script to the object", "didAdd"));
        intrinsic.AddParam(ScriptNameVal.value);
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
                return Intrinsic.Result.Null;
            ValString scriptName = context.GetVar(ScriptNameVal) as ValString;
            if (scriptName == null)
                return Intrinsic.Result.Null;

            //Debug.Log("will add script " + scriptName);
            // First try to get a user script by the provided name
            BehaviorInfo scriptInfo = UserScriptManager.Instance.GetScriptByName(scriptName.value);
            // If none found, check the built in scripts
            if (scriptInfo == null)
                scriptInfo = CSharpBehaviorManager.Instance.GetScriptByName(scriptName.value);
            if (scriptInfo == null)
            {
                UserScriptManager.LogToCode(context, "No Script named \"" + scriptName.value + "\"", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            //Debug.Log("Adding behavior " + scriptInfo.Name);
            if(sceneObject.GetAttachedBehavior(scriptInfo.IsNetworkedScript(), scriptInfo.BehaviorID) != null)
            {
                UserScriptManager.LogToCode(context, "Script \"" + scriptName.value + "\" already added", UserScriptManager.CodeLogType.Warning);
                return Intrinsic.Result.Null;
            }

            sceneObject.AddBehavior(scriptInfo, true, true, null);
            return Intrinsic.Result.True;
		};

        intrinsic = Intrinsic.Create("RemoveScript");
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Removes a script by name from the object", "didRem"));
        intrinsic.AddParam(ScriptNameVal.value);
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
                return Intrinsic.Result.Null;
            ValString scriptName = context.GetVar(ScriptNameVal) as ValString;
            if (scriptName == null)
                return Intrinsic.Result.Null;

            //Debug.Log("will add script " + scriptName);
            // First try to get a user script by the provided name
            BehaviorInfo scriptInfo = UserScriptManager.Instance.GetScriptByName(scriptName.value);
            // If none found, check the built in scripts
            if (scriptInfo == null)
                scriptInfo = CSharpBehaviorManager.Instance.GetScriptByName(scriptName.value);
            if (scriptInfo == null)
            {
                UserScriptManager.LogToCode(context, "No Script named \"" + scriptName.value + "\"", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            //Debug.Log("Adding behavior " + scriptInfo.Name);
            BaseBehavior script = sceneObject.GetAttachedBehavior(scriptInfo.IsNetworkedScript(), scriptInfo.BehaviorID);
            if(script == null)
            {
                UserScriptManager.LogToCode(context, "Script \"" + scriptName.value + "\" not attached", UserScriptManager.CodeLogType.Warning);
                return Intrinsic.Result.Null;
            }
            sceneObject.RemoveBehavior(script, true);
            return Intrinsic.Result.True;
		};
        intrinsic = Intrinsic.Create("HasScript");
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Returns if the object has a script by name", "doesHave"));
        intrinsic.AddParam(ScriptNameVal.value);
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
                return Intrinsic.Result.Null;
            ValString scriptName = context.GetVar(ScriptNameVal) as ValString;
            if (scriptName == null)
                return Intrinsic.Result.Null;

            //Debug.Log("will add script " + scriptName);
            // First try to get a user script by the provided name
            BehaviorInfo scriptInfo = UserScriptManager.Instance.GetScriptByName(scriptName.value);
            // If none found, check the built in scripts
            if (scriptInfo == null)
                scriptInfo = CSharpBehaviorManager.Instance.GetScriptByName(scriptName.value);
            if (scriptInfo == null)
            {
                UserScriptManager.LogToCode(context, "No Script named \"" + scriptName.value + "\"", UserScriptManager.CodeLogType.Error);
                return Intrinsic.Result.Null;
            }
            //Debug.Log("Adding behavior " + scriptInfo.Name);
            if (sceneObject.GetAttachedBehavior(scriptInfo.IsNetworkedScript(), scriptInfo.BehaviorID) != null)
                return Intrinsic.Result.True;
            return Intrinsic.Result.False;
		};
        intrinsic = Intrinsic.Create("SetEnabled");
        intrinsic.AddParam(EnabledVal.value);
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Turn this object on or off", null));
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
                return Intrinsic.Result.Null;
            ValNumber enabledVal = context.GetVar(EnabledVal) as ValNumber;
            if (enabledVal == null)
                return Intrinsic.Result.Null;

            bool enabled = enabledVal.BoolValue();
            sceneObject.SetEnabled(enabled, true);
            return Intrinsic.Result.Null;
		};
        intrinsic = Intrinsic.Create("SetVisible");
        intrinsic.AddParam(EnabledVal.value);
        _alwaysExposedFunctions.Add(new ExposedFunction(intrinsic, "Make this object (in)visible", null));
        intrinsic.code = (context, partialResult) => {
            SceneObject sceneObject = UserScriptManager.GetSceneObjectFromContext(context);
            if(sceneObject == null)
                return Intrinsic.Result.Null;
            ValNumber enabledVal = context.GetVar(EnabledVal) as ValNumber;
            if (enabledVal == null)
                return Intrinsic.Result.Null;

            bool enabled = enabledVal.BoolValue();
            // TODO clean this up
            if (sceneObject.Model != null)
                sceneObject.Model.SetActive(enabled);
            return Intrinsic.Result.Null;
		};
    }
    void Update()
    {
        if (_debugText != null && _drObject != null)
            _debugText.text = _drObject.OwnerID.ToString() + " | " + _drObject.OwnershipTime;
        if (Input.GetKeyDown(KeyCode.F11))
        {
            Rigidbody r = Rigidbody;
            if(r != null && PhysicsFollower == null)
            {
                // Request kinematic be true
                _behaviorKinematicRequests.AddRequest(true, null, 0);
                RefreshKinematic();
                PhysicsFollower = SimplePool.Instance.Spawn(PhysicsFollowManager.Instance.PhysicsFollowPrefab).GetComponent<PhysicsFollowHand>();
                PhysicsFollower.Init(this);
            }
        }
        if (Input.GetKeyDown(KeyCode.F12))
        {
            if(PhysicsFollower != null)
            {
                PhysicsFollower.ResetState();
                SimplePool.Instance.Despawn(PhysicsFollower.gameObject);
                PhysicsFollower = null;
            }
        }
        //if(_photonView != null)
        //{
            //_debugText.SetText(_photonView.OwnerActorNr.ToString());
        //}
    }
}
